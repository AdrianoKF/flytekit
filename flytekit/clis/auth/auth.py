import webbrowser
import base64
import hashlib
import os
import re
import requests
from multiprocessing import Process, Queue

try:  # Python 3.5+
    from http import HTTPStatus as StatusCodes
except ImportError:
    try:  # Python 3
        from http import client as StatusCodes
    except ImportError:  # Python 2
        import httplib as StatusCodes
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler

from urlparse import urlparse, urljoin, parse_qsl

code_verifier_length = 64


def generate_code_verifier():
    """
    Generates a 'code_verifier' as described in section 4.1 of RFC 7636.
    Adapted from https://github.com/openstack/deb-python-oauth2client/blob/master/oauth2client/_pkce.py.
    :return str:
    """
    code_verifier = base64.urlsafe_b64encode(os.urandom(code_verifier_length)).decode('utf-8')
    # Eliminate invalid characters.
    code_verifier = re.sub('[^a-zA-Z0-9]+', '', code_verifier)
    if len(code_verifier) < 43:
        raise ValueError("Verifier too short. number of bytes must be > 30.")
    elif len(code_verifier) > 128:
        raise ValueError("Verifier too long. number of bytes must be < 97.")
    return code_verifier


# TODO(katrogan): Figure out how random this needs to be
def generate_state_parameter():
    state = base64.urlsafe_b64encode(os.urandom(40)).decode('utf-8')
    # Eliminate invalid characters.
    code_verifier = re.sub('[^a-zA-Z0-9-_.,]+', '', state)
    return code_verifier


def create_code_challenge(code_verifier):
    """
    Adapted from https://github.com/openstack/deb-python-oauth2client/blob/master/oauth2client/_pkce.py.
    :param str code_verifier: represents a code verifier generated by generate_code_verifier()
    :return str: urlsafe base64-encoded sha256 hash digest
    """
    code_challenge = hashlib.sha256(code_verifier.encode('utf-8')).digest()
    code_challenge = base64.urlsafe_b64encode(code_challenge).decode('utf-8')
    # Eliminate invalid characters
    code_challenge = code_challenge.replace('=', '')
    return code_challenge


class AuthorizationCode(object):
    def __init__(self, code, state):
        self._code = code
        self._state = state

    @property
    def code(self):
        return self._code

    @property
    def state(self):
        return self._state

    def __repr__(self):
        return "[{}, {}]".format(self.code, self.state)


class OAuthCallbackHandler(BaseHTTPRequestHandler):
    """
    A simple wrapper around BaseHTTPServer.BaseHTTPRequestHandler that handles a callback URL that accepts an
    authorization token.
    """

    def do_GET(self):
        url = urlparse(self.path)
        if url.path == self.server.redirect_path:
            self.send_response(StatusCodes.OK)
            self.end_headers()
            self.handle_login(dict(parse_qsl(url.query)))
        else:
            self.send_response(404)

    def handle_login(self, data):
        self.server.handle_authorization_code(AuthorizationCode(data['code'], data['state']))


class OAuthHTTPServer(HTTPServer):
    """
    A simple wrapper around the BaseHTTPServer.HTTPServer implementation that binds an authorization_client for handling
    authorization code callbacks.
    """
    def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True,
                 redirect_path=None, queue=None):
        HTTPServer.__init__(self, server_address, RequestHandlerClass, bind_and_activate)
        self._redirect_path = redirect_path
        self._auth_code = None
        self._queue = queue

    @property
    def redirect_path(self):
        return self._redirect_path

    def handle_authorization_code(self, auth_code):
        self._queue.put(auth_code)


class Credentials(object):
    # TODO(katrogan): Also add expires_in handling.
    def __init__(self, access_token=None, id_token=None):
        self._access_token = access_token
        self._id_token = id_token

    @property
    def access_token(self):
        return self._access_token

    @property
    def id_token(self):
        return self._id_token


# TODO:
#  do we need to support initiate login URI? https://devforum.okta.com/t/initiate-login-uri-for-all-subdomain-urls/3766


class AuthorizationClient(object):
    def __init__(self, auth_endpoint=None, token_endpoint=None, client_id=None, redirect_path=None):
        self._auth_endpoint = auth_endpoint
        self._token_endpoint = token_endpoint
        self._client_id = client_id
        self._redirect_path = redirect_path
        self._code_verifier = generate_code_verifier()
        code_challenge = create_code_challenge(self._code_verifier)
        self._code_challenge = code_challenge
        state = generate_state_parameter()
        self._state = state
        self._credentials = None

        self._params = {
            # TODO: need an audience param here?
            "client_id": client_id,  # This must match the Client ID of the OAuth application.
            "response_type": "code",  # Indicates the authorization code grant
            "scope": "openid",  # ensures that the /token endpoint returns an ID token
            # callback location where the user-agent will be directed to.
            "redirect_uri": urljoin("http://localhost:8088", self._redirect_path),
            "state": state,
            "code_challenge": code_challenge,
            "code_challenge_method": "S256",
        }

        # Initialize token request flow
        self._request_authorization_code()
        # Start a server to handle the callback url.
        self._start_callback_server()

    def _start_callback_server(self):
        # TODO: change okta application port
        server_address = ('localhost', 8088)
        q = Queue()
        server = OAuthHTTPServer(server_address, OAuthCallbackHandler, redirect_path=self._redirect_path, queue=q)
        server_process = Process(target=server.handle_request)

        server_process.start()
        auth_code = q.get()
        server_process.terminate()
        self.request_access_token(auth_code)

    def _request_authorization_code(self):
        # Spin up a background local http server to receive the callback request containing the authorization code
        resp = requests.get(
            url=self._auth_endpoint,
            params=self._params,
            allow_redirects=False
        )
        if resp.status_code == StatusCodes.FOUND:
            # Follow the redirect
            redirect_location = resp.headers['Location']
            if redirect_location is None:
                raise ValueError('Received a 302 but no follow up location was provided in headers')
            webbrowser.open_new_tab(redirect_location)

    def request_access_token(self, auth_code):
        if self._state != auth_code.state:
            raise ValueError("Unexpected state parameter [{}] passed".format(auth_code.state))
        self._params.update({
            "code": auth_code.code,
            "code_verifier": self._code_verifier,
            "grant_type": "authorization_code",
        })
        resp = requests.post(
            url=self._token_endpoint,
            data=self._params,
            headers={'content-type': "application/x-www-form-urlencoded"},
            allow_redirects=False
        )
        if resp.status_code != StatusCodes.OK:
            # TODO: handle expected (?) error cases:
            #  https://auth0.com/docs/flows/guides/device-auth/call-api-device-auth#token-responses
            raise Exception('Failed to request access token with response: [{}] {}'.format(
                resp.status_code, resp.content))

        """
        The response body is of the form:
        {
          "access_token": "foo",
          "refresh_token": "bar",
          "id_token": "baz",
          "token_type": "Bearer"
        }
        """
        response_body = resp.json()
        if "access_token" not in response_body:
            raise ValueError('Expected "access_token" in response from oauth server')

        self._credentials = Credentials(access_token=response_body["access_token"], id_token=response_body["id_token"])

    def credentials(self):
        return self._credentials


if __name__ == '__main__':
    client = AuthorizationClient(redirect_path="/callback", client_id="my_client",
                                 auth_endpoint="https://myoauth.com/oauth2/default/v1/authorize",
                                 token_endpoint="https://myoauth.com/oauth2/default/v1/token")
    client.credentials()
